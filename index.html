<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Exercices ‚Äî Verbes italiens (QCM / Saisie libre)</title>
  <style>
    :root{
      --bg:#0b1224; --panel:#0f172a; --card:#101a33; --ink:#eaf0fb; --muted:#9fb0c7;
      --brand:#38bdf8; --brand2:#a78bfa; --good:#22c55e; --bad:#ef4444; --border:#1d2b4f;
      --yellow:#facc15; --yellow-ink:#ffe88a; --yellow-bg:#2b2300; --yellow-border:#5a4500;
      --orange:#fb923c; --orange-bg:#2b1700; --orange-border:#6b2b00;
      --radius:16px; --shadow:0 12px 28px rgba(0,0,0,.35)
    }
    html,body{margin:0; background:
      radial-gradient(1200px 600px at 10% -10%, #152244 0%, transparent 60%),
      radial-gradient(900px 600px at 100% 0%, #1b2c52 0%, transparent 55%),
      linear-gradient(180deg, var(--bg), #0e162c);
      color:var(--ink); font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    *,*:before,*:after{box-sizing:border-box}

    header{padding:26px 16px 8px; text-align:center}
    header h1{margin:0 0 6px; font-size:1.6rem}
    header p{margin:0; color:var(--muted)}

    .wrap{max-width:1000px; margin:0 auto; padding:14px}
    .panel{background:var(--panel); border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow); overflow:hidden}
    .panel header{padding:14px 16px; text-align:left; border-bottom:1px solid var(--border)}
    .panel header h2{margin:0; font-size:1.05rem}

    .grid{display:grid; gap:14px}
    @media(min-width:900px){.grid{grid-template-columns:1.1fr .9fr}}

    .card{background:var(--card); border:1px solid var(--border); border-radius:14px; padding:14px}
    .card.yellow{background:var(--yellow-bg); border-color:var(--yellow-border); box-shadow:0 0 0 2px rgba(250,204,21,.12) inset}
    .card.orange{background:var(--orange-bg); border-color:var(--orange-border); box-shadow:0 0 0 2px rgba(251,146,60,.16) inset}

    .controls{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    .chip{display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:999px; background:#152346; border:1px solid #1b2b58; color:#cfe8ff; font-weight:700}
    .chip input{accent-color:var(--brand)}

    .verb-list{display:grid; grid-template-columns:repeat(auto-fit, minmax(220px, 1fr)); gap:12px}
    .verb{display:flex; align-items:flex-start; gap:10px; padding:12px 14px; background:#0f1a33; border:1px solid #13244a; border-radius:12px}
    .verb input{accent-color:var(--brand); margin-top:2px}
    .verb .vcol{display:flex; flex-direction:column; line-height:1.15}
    .verb .it{font-weight:800; font-size:1rem}
    .verb .fr{color:var(--muted); font-size:.9rem}

    .bar{display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between; padding:10px; background:#0d1832; border:1px solid var(--border); border-radius:12px}
    .bar .counters{display:flex; gap:10px; font-weight:900}

    button{appearance:none; background:linear-gradient(180deg, var(--brand), #119bd4); color:#fff; border:0; padding:10px 14px; border-radius:12px; font-weight:800; letter-spacing:.2px; box-shadow:var(--shadow); cursor:pointer; transition:.15s}
    button.ghost{background:#162549}
    button:active{transform:translateY(1px)}
    @media(hover:hover){button:hover{filter:brightness(1.07); transform:translateY(-1px)}}

    .question{font-size:1.05rem; font-weight:800; display:flex; align-items:center; gap:8px; flex-wrap:wrap}
    .badge{display:inline-flex; align-items:center; gap:6px; padding:3px 8px; border-radius:999px; font-size:.75rem; font-weight:900}
    .badge.yellow{border:1px solid var(--yellow-border); background:var(--yellow-bg); color:var(--yellow)}
    .badge.orange{border:1px solid var(--orange-border); background:var(--orange-bg); color:var(--orange)}
    .badge.prol{border:1px solid #334155; background:#0e1a35; color:#cbd5e1}

    .choices{display:grid; gap:10px; margin-top:12px}
    @media(min-width:720px){.choices{grid-template-columns:1fr 1fr}}
    .choice{display:flex; align-items:center; justify-content:space-between; gap:10px; background:#0f1a33; border:1px solid #13244a; border-radius:12px; padding:12px 14px; font-weight:800; cursor:pointer}
    .card.yellow .choice{background:#1b1603; border-color:#3b2f03}
    .card.orange .choice{background:#241403; border-color:#4b2b07}
    .choice.correct{outline:2px solid var(--good)}
    .choice.wrong{outline:2px solid var(--bad)}
    .choice.debug-hint{outline:2px dashed var(--good); box-shadow:0 0 0 2px rgba(34,197,94,.15) inset}

    .feedback{margin-top:10px; font-weight:800}
    .ok{color:var(--good)} .ko{color:var(--bad)}

    .history{display:grid; gap:8px}
    .hist-item{display:grid; gap:6px; border:1px dashed #1b2b58; border-radius:10px; padding:10px}
    .hist-head{display:flex; justify-content:space-between; gap:8px; font-weight:800}
    .hist-head .tag{padding:2px 8px; border-radius:999px}
    .hist-head .tag.yellow{background:var(--yellow-bg); border:1px solid var(--yellow-border); color:var(--yellow)}
    .hist-head .tag.orange{background:var(--orange-bg); border:1px solid var(--orange-border); color:var(--orange)}
    .hist-body{color:var(--muted)}

    .debug-ans{margin-top:8px; color:var(--good); font-weight:800}

    .hidden{display:none!important}
    .note{color:var(--muted); font-size:.9rem}
    .warn{background:#3a0d13; color:#ffd6db; border:1px solid #7a1a23; padding:10px 12px; border-radius:12px}
  </style>
</head>
<body>
  <header>
    <h1>Exercices ‚Äî Verbes italiens</h1>
    <p>Choisis tes verbes (charg√©s depuis <code>verbs.json</code>), ton mode (QCM ou saisie libre) et lance une s√©rie sans r√©p√©tition. Si le nombre demand√© d√©passe les uniques, on ajoute des reprises : <strong>orange</strong> (erreurs non r√©solues) en priorit√©, puis <strong>jaune</strong> (long temps de r√©flexion).</p>
  </header>

  <div class="wrap">
    <!-- CONFIGURATION -->
    <section class="panel" id="config">
      <header><h2>‚öôÔ∏è Configuration de l'exercice</h2></header>
      <div class="grid">
        <div class="card">
          <div class="controls" style="margin-bottom:10px">
            <label class="chip"><input type="radio" name="mode" value="qcm" checked> QCM</label>
            <label class="chip"><input type="radio" name="mode" value="saisie"> Saisie libre</label>
            <label class="chip" title="Toujours actif pour CHIAMARSI"><input type="checkbox" id="fullForm" checked> Forme compl√®te (pronoms)</label>
            <label class="chip" title="Affiche la bonne r√©ponse en vert pour contr√¥le"><input type="checkbox" id="debugMode"> Mode debug</label>
          </div>
          <p class="note">Place un fichier <code>verbs.json</code> √† c√¥t√© de cette page pour alimenter la liste. Sans ce fichier, le d√©marrage sera bloqu√©.</p>
          <div id="loadWarn" class="warn hidden">‚ùå Impossible de charger <code>verbs.json</code>. Ajoute le fichier puis recharge la page.</div>
        </div>
        <div class="card">
          <strong>Verbes √† inclure :</strong>
          <div id="verbsList" class="verb-list" aria-live="polite"></div>
        </div>
      </div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin:12px 14px 16px">
        <button id="start" disabled>üöÄ Lancer</button>
      </div>
    </section>

    <!-- QUIZ -->
    <section class="panel hidden" id="quiz">
      <header>
        <h2>üß™ Exercice en cours</h2>
        <div class="bar" role="status">
          <div class="counters">
            <div>Progression : <span id="progress">1/20</span></div>
            <div id="prolBadge" class="badge prol hidden">Prolongation</div>
            <div>Bonnes r√©ponses : <span id="score">0</span></div>
          </div>
          <div style="display:flex; gap:8px">
            <button id="reset" class="ghost">‚Üª Reset</button>
            <button id="backToConfig" class="ghost">‚öôÔ∏è Options</button>
          </div>
        </div>
      </header>
      <div class="grid">
        <div class="card" id="currentQ">
          <div class="question" id="qText">‚Ä¶</div>
          <div id="modeQCM" class="choices hidden" role="listbox" aria-label="Choix de r√©ponse"></div>
          <div id="modeInput" class="hidden">
            <form id="freeForm" autocomplete="off" style="display:flex; gap:8px; margin-top:12px">
              <input id="answer" type="text" inputmode="latin" placeholder="√âcris ta r√©ponse en italien" style="flex:1; padding:12px 14px; border-radius:12px; background:#0f1a33; border:1px solid #13244a; color:var(--ink); font-weight:700" />
              <button>Valider</button>
            </form>
          </div>
          <div class="debug-ans hidden" id="debugAns"></div>
          <div class="feedback" id="feedback"></div>
        </div>
        <div class="card">
          <strong>Historique</strong>
          <div id="history" class="history" aria-live="polite"></div>
          <div id="endActions" class="hidden" style="margin-top:10px; display:flex; gap:10px">
            <button id="replay">üîÅ Rejouer</button>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
  // ===== Utilitaires =====
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  const normalize = s => (s||"")
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/‚Äô/g, "'")
    .replace(/\s+/g,' ')
    .trim();

  // ===== Chargement JSON externe uniquement =====
  async function loadVerbs(){
    const warn = $('#loadWarn');
    try{
      const res = await fetch('verbs.json', {cache:'no-store'});
      if(!res.ok) throw new Error('HTTP '+res.status);
      const data = await res.json();
      if(!data || !Array.isArray(data.verbs)) throw new Error('format');
      warn.classList.add('hidden');
      return data;
    }catch(e){
      warn.classList.remove('hidden');
      return null;
    }
  }

  // ===== √âtat global =====
  const STATE = {
    data:null,
    selectedVerbIds:new Set(),
    mode:'qcm', // 'qcm' | 'saisie'
    fullForm:true,
    baseTotal:20, // demand√© initial
    capTotal:60,  // baseTotal + 2*baseTotal
    idx:0,
    good:0,
    history:[],
    current:null,
    queue:[], // file d'attente des questions (objets)
    uniquePool:[], // toutes les questions uniques possibles pour cette config
    phase:'uniques', // 'uniques' | 'subs_pre' | 'subs_loop'
    prolongation:false,
    debug:false,
    qStart:0,
    stats:new Map(), // key => {attempts, hadCorrect, maxDur, lastSrc}
    unresolved:new Set(), // keys en erreur non r√©solue (ORANGE)
    repeatedYellowFrom:new Set() // pour limiter √† 1 reprise jaune par source
  };

  // ===== Construction UI config =====
  function renderVerbChecks(verbs){
    const box = $('#verbsList'); box.innerHTML = '';
    verbs.forEach(v => {
      const id = `verb-${v.id}`;
      const el = document.createElement('label');
      el.className = 'verb';
      el.innerHTML = `<input type=\"checkbox\" id=\"${id}\" value=\"${v.id}\"> <div class=\"vcol\"><div class=\"it\">${v.it}</div><div class=\"fr\">‚Äî ${v.fr}</div></div>`;
      box.appendChild(el);
      el.querySelector('input').addEventListener('change', onVerbToggle);
    });
    onVerbToggle();
  }
  function onVerbToggle(){
    const any = $$('#verbsList input[type="checkbox"]').some(c => c.checked);
    $('#start').disabled = !any || !STATE.data; // bloque si pas de donn√©es
  }

  function readConfig(){
    STATE.mode = ($$('input[name="mode"]').find(r=>r.checked)||{}).value || 'qcm';
    STATE.fullForm = $('#fullForm').checked;
    STATE.selectedVerbIds = new Set(
      $$('#verbsList input[type="checkbox"]').filter(c=>c.checked).map(c=>c.value)
    );
  }

  // ===== Debug auth =====
  function ensureDebugAuth(){
    const wantDebug = $('#debugMode').checked;
    const persisted = sessionStorage.getItem('debug') === '1';
    if(!wantDebug){
      sessionStorage.removeItem('debug');
      STATE.debug = false;
      return true;
    }
    if(persisted){ STATE.debug = true; return true; }
    const pwd = prompt('Mot de passe debug :');
    if(pwd === null) return false; // annul√©
    if(pwd === 'birdy'){
      sessionStorage.setItem('debug','1');
      STATE.debug = true;
      return true;
    } else {
      alert('Mot de passe incorrect');
      STATE.debug = false;
      return false;
    }
  }

  // ===== G√©n√©ration: pool unique & file =====
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function shuffle(arr){ return arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]); }

  function buildUniquePool(){
    const pool = [];
    const seen = new Set();
    const verbs = STATE.data.verbs.filter(v=> STATE.selectedVerbIds.has(v.id));
    for(const v of verbs){
      for(const f of v.forms){
        const mustFull = v.id === 'chiamarsi' ? true : STATE.fullForm;
        const answer = (mustFull ? f.full : f.it).split('|')[0].trim();
        const key = `${v.id}:${f.person}:${mustFull}`;
        if(seen.has(key)) continue;
        seen.add(key);
        pool.push({ key, verb:v, form:f, prompt:f.fr, answer, mustFull, subsidiary:false, subType:null });
      }
    }
    return pool;
  }

  function prepareQueue(N){
    STATE.uniquePool = buildUniquePool();
    const P = STATE.uniquePool.length;
    const base = shuffle(STATE.uniquePool);
    STATE.queue = base.slice(0, Math.min(N, P));
    STATE.baseTotal = N;
    STATE.capTotal = N + 2*N;
    STATE.idx = 0; STATE.good = 0; STATE.history = []; STATE.current = null; STATE.qStart = 0;
    STATE.phase = 'uniques'; STATE.prolongation = false;
    STATE.stats = new Map(); STATE.unresolved = new Set(); STATE.repeatedYellowFrom = new Set();
    updateCounters();
  }

  // ===== Demande du nombre de questions =====
  function getRequestedCount(){
    const def = parseInt(sessionStorage.getItem('qCount')||'20',10);
    const input = prompt('Combien de questions ? (ex: 20)', isNaN(def)?'20':String(def));
    if(input===null) return null; // annul√©
    const n = parseInt(input,10);
    if(!Number.isFinite(n) || n<=0){ alert('Entr√©e invalide.'); return null; }
    sessionStorage.setItem('qCount', String(n));
    return n;
  }

  // ===== S√©lection des reprises =====
  function keyStatsEnsure(key){
    if(!STATE.stats.has(key)) STATE.stats.set(key, {attempts:0, hadCorrect:false, maxDur:0, lastSrc:null});
    return STATE.stats.get(key);
  }

  function cloneAs(src, subType){
    return { key:src.key, verb:src.verb, form:src.form, prompt:src.prompt, answer:src.answer, mustFull:src.mustFull, subsidiary:true, subType };
  }

  function getSrcByKey(key){
    // cherche dans uniquePool d'abord, sinon depuis la derni√®re trace en stats
    const base = STATE.uniquePool.find(x=>x.key===key);
    if(base) return base;
    const st = STATE.stats.get(key);
    return st && st.lastSrc ? st.lastSrc : null;
  }

  function longestYellowCandidates(excludeKeys=new Set()){
    // candidates √©ligibles aux jaunes: vus au moins une fois et non non-r√©solus
    const arr = [];
    STATE.stats.forEach((st, key)=>{
      if(STATE.unresolved.has(key)) return; // non r√©solue ‚Üí pas jaune
      if(excludeKeys.has(key)) return;
      if(STATE.repeatedYellowFrom.has(key)) return; // max 1 jaune par source
      if(st.maxDur>0 && st.lastSrc){ arr.push({key, st}); }
    });
    arr.sort((a,b)=> b.st.maxDur - a.st.maxDur);
    return arr.map(x=> cloneAs(x.st.lastSrc, 'yellow'));
  }

  function unresolvedOrangeCandidates(excludeKeys=new Set()){
    const list = [];
    for(const key of STATE.unresolved){
      if(excludeKeys.has(key)) continue;
      const src = getSrcByKey(key);
      if(src) list.push(cloneAs(src, 'orange'));
    }
    return list;
  }

  function fillPreBaseIfNeeded(){
    if(STATE.phase==='uniques' && STATE.queue.length===0){
      STATE.phase = 'subs_pre';
    }
    if(STATE.phase!=='subs_pre') return;
    const need = Math.max(0, STATE.baseTotal - STATE.idx - STATE.queue.length);
    if(need<=0) return;

    const exclude = new Set();
    const oranges = unresolvedOrangeCandidates(exclude);
    const picked = [];
    for(const o of oranges){
      if(picked.length>=need) break;
      picked.push(o); exclude.add(o.key);
    }
    if(picked.length<need){
      const yellows = longestYellowCandidates(exclude);
      for(const y of yellows){
        if(picked.length>=need) break;
        picked.push(y); exclude.add(y.key);
        STATE.repeatedYellowFrom.add(y.key);
      }
    }
    STATE.queue.push(...picked);
  }

  function enterProlongation(){
    if(STATE.prolongation) return;
    STATE.prolongation = true;
    $('#prolBadge').classList.remove('hidden');
    STATE.phase = 'subs_loop';
  }

  function fillProlongation(){
    if(!STATE.prolongation) return;
    if(STATE.queue.length>0) return;
    if(STATE.unresolved.size===0) return;

    // Alternance Orange -> Jaune
    const exclude = new Set();
    const oranges = unresolvedOrangeCandidates(exclude);
    if(oranges.length){
      const o = oranges[0]; STATE.queue.push(o); exclude.add(o.key);
    }
    let yadded = false;
    const yellows = longestYellowCandidates(exclude);
    if(yellows.length){
      const y = yellows[0]; STATE.queue.push(y); exclude.add(y.key); STATE.repeatedYellowFrom.add(y.key); yadded = true;
    }
    // Si aucune jaune dispo, ins√©rer un filler depuis une juste vue (m√™me logique que yellow, mais sans maxDur? on r√©utilise tri)
    if(!yadded && STATE.unresolved.size>0){
      // chercher n'importe quelle juste vue (m√™me si d√©j√† yellow une fois) avec maxDur>0
      const anyJuste = [];
      STATE.stats.forEach((st,key)=>{ if(!STATE.unresolved.has(key) && st.maxDur>0 && st.lastSrc){ anyJuste.push({key, st}); }});
      anyJuste.sort((a,b)=> b.st.maxDur - a.st.maxDur);
      if(anyJuste.length){ const f = cloneAs(anyJuste[0].st.lastSrc, 'yellow'); STATE.queue.push(f); }
    }
  }

  // ===== M√©canique du quiz =====
  async function startQuiz(){
    readConfig();

    // Auth debug avant tout
    if(!ensureDebugAuth()) return;

    const requested = getRequestedCount();
    if(requested===null) return; // annul√©

    prepareQueue(requested);
    $('#config').classList.add('hidden');
    $('#quiz').classList.remove('hidden');
    $('#history').innerHTML = ''; $('#endActions').classList.add('hidden');
    askNext();
  }

  function updateCounters(){
    const idx1 = Math.min(STATE.idx+1, Math.max(STATE.baseTotal, STATE.idx+1));
    if(STATE.prolongation){
      const extra = Math.max(0, idx1 - STATE.baseTotal);
      $('#progress').textContent = `${STATE.baseTotal} + ${extra}`;
    } else {
      $('#progress').textContent = `${idx1}/${STATE.baseTotal}`;
    }
    $('#score').textContent = STATE.good;
  }

  function endIfDone(){
    // Fin si: (avant prolongation) idx>=baseTotal et aucune non-r√©solue
    if(!STATE.prolongation){
      if(STATE.idx>=STATE.baseTotal){
        if(STATE.unresolved.size>0){ enterProlongation(); return false; }
        finish(); return true;
      }
      return false;
    }
    // en prolongation: fin si plus d'orange OU cap atteint
    if(STATE.unresolved.size===0 || STATE.idx>=STATE.capTotal){ finish(); return true; }
    return false;
  }

  function finish(){
    $('#qText').textContent = 'Termin√© !';
    $('#modeQCM').classList.add('hidden');
    $('#modeInput').classList.add('hidden');
    const extra = STATE.prolongation ? ` (prolongation +${Math.max(0, STATE.idx - STATE.baseTotal)})` : '';
    $('#feedback').innerHTML = `<span class="ok">Score final : ${STATE.good}/${Math.max(STATE.baseTotal, STATE.idx)}</span>${extra}`;
    $('#endActions').classList.remove('hidden');
  }

  function askNext(){
    if(endIfDone()) return;

    // Gestion des files selon la phase
    if(STATE.phase==='uniques' && STATE.queue.length===0){ STATE.phase='subs_pre'; }
    if(STATE.phase==='subs_pre') fillPreBaseIfNeeded();
    if(STATE.idx>=STATE.baseTotal && STATE.unresolved.size>0){ enterProlongation(); }
    if(STATE.phase==='subs_loop') fillProlongation();

    if(STATE.queue.length===0){
      // s√©curit√©: si vraiment vide et rien √† poser
      finish();
      return;
    }

    STATE.current = STATE.queue.shift();

    const card = document.getElementById('currentQ');
    card.classList.remove('yellow','orange');
    let badge = '';
    if(STATE.current.subsidiary){
      if(STATE.current.subType==='orange'){ card.classList.add('orange'); badge = '<span class="badge orange">ORANGE</span>'; }
      else { card.classList.add('yellow'); badge = '<span class="badge yellow">SUBSIDIARY</span>'; }
    }

    const qt = `Comment dit‚Äëon ¬´ ${STATE.current.prompt} ¬ª en italien ?`;
    $('#qText').innerHTML = `${STATE.prolongation? '<span class="badge prol">Prolongation</span> ' : ''}${badge} ${qt}`;
    $('#feedback').textContent = '';

    // Debug hint for input
    const dbg = $('#debugAns');
    if(STATE.debug){ dbg.textContent = `DEBUG ‚Äî r√©ponse attendue : ${STATE.current.answer}`; dbg.classList.remove('hidden'); }
    else { dbg.classList.add('hidden'); }

    // d√©marrer le chrono
    STATE.qStart = Date.now();

    if(STATE.mode==='qcm'){
      const box = $('#modeQCM'); box.innerHTML = ''; box.classList.remove('hidden');
      $('#modeInput').classList.add('hidden');
      const options = makeQcmChoices(STATE.current);
      options.forEach(opt=>{
        const btn = document.createElement('button');
        btn.type='button'; btn.className='choice'; btn.innerHTML = `<span>${opt}</span>`;
        if(STATE.debug && normalize(opt)===normalize(STATE.current.answer)){
          btn.classList.add('debug-hint');
        }
        btn.addEventListener('click', ()=> handleQcmClick(opt, btn));
        box.appendChild(btn);
      });
    }else{
      $('#modeQCM').classList.add('hidden');
      $('#modeInput').classList.remove('hidden');
      $('#answer').value = '';
      $('#answer').focus();
    }

    updateCounters();
  }

  function recordHistory(isCorrect, given, correct){
    const dur = Math.max(0, Date.now() - (STATE.qStart||Date.now()));
    const key = STATE.current.key;
    const wasSubs = !!STATE.current.subsidiary;
    const subType = STATE.current.subType;

    // maj stats
    const st = keyStatsEnsure(key);
    st.attempts++; st.maxDur = Math.max(st.maxDur||0, dur); st.lastSrc = st.lastSrc || { ...STATE.current, subsidiary:false, subType:null };
    if(isCorrect){ st.hadCorrect = true; STATE.unresolved.delete(key); } else { if(!st.hadCorrect) STATE.unresolved.add(key); }

    STATE.history.unshift({ q: `¬´ ${STATE.current.prompt} ¬ª`, given, correct, ok:isCorrect, src: { ...STATE.current, subsidiary:false }, dur, idx: STATE.idx+1, wasSubs, subType });

    const item = document.createElement('div');
    item.className = 'hist-item';
    const tag = wasSubs ? `<span class="tag ${subType==='orange'?'orange':'yellow'}">${subType==='orange'?'ORANGE':'SUBSIDIARY'}</span>` : '';
    const durSec = (dur/1000).toFixed(1)+'s';
    item.innerHTML = `
      <div class="hist-head">
        <div>${tag} ${STATE.history[0].q} ¬∑ <span title="Temps de r√©ponse">${durSec}</span></div>
        <div class="${isCorrect? 'ok':'ko'}">${isCorrect?'‚úÖ R√©ussi':'‚ùå Faux'}</div>
      </div>
      <div class="hist-body">
        Ta r√©ponse : <strong>${given||'‚Äî'}</strong><br>
        ${isCorrect? '' : `Bonne r√©ponse : <strong>${correct}</strong>`}
      </div>`;
    $('#history').prepend(item);
  }

  async function afterAnswer(isCorrect){
    if(isCorrect){ STATE.good++; }
    // Si on est en phase subs (pr√©-base ou prolongation) et que c'√©tait une ORANGE fausse, la replanifier √† +1
    if(!isCorrect && STATE.current.subsidiary && STATE.current.subType==='orange'){
      // r√©insertion rapide : une question entre les deux
      const src = getSrcByKey(STATE.current.key);
      if(src){
        const again = cloneAs(src, 'orange');
        STATE.queue.splice(1, 0, again); // +1
      }
    }

    STATE.idx++;
    updateCounters();
    await sleep(500);
    askNext();
  }

  // QCM
  function handleQcmClick(choice, btn){
    const correct = STATE.current.answer;
    const ok = normalize(choice)===normalize(correct);
    $$('#modeQCM .choice').forEach(b=> b.disabled=true);
    btn.classList.add(ok? 'correct':'wrong');
    $('#feedback').innerHTML = ok ? '<span class="ok">‚úÖ Correct</span>' : `<span class=\"ko\">‚ùå Faux</span> ‚Üí Bonne r√©ponse : <strong>${correct}</strong>`;
    recordHistory(ok, choice, correct);
    afterAnswer(ok);
  }

  // Saisie libre
  $('#freeForm')?.addEventListener('submit', (e)=>{
    e.preventDefault();
    const val = $('#answer').value;
    const correct = STATE.current.answer;
    const ok = normalize(val)===normalize(correct);
    $('#feedback').innerHTML = ok ? '<span class="ok">‚úÖ Correct</span>' : `<span class=\"ko\">‚ùå Faux</span> ‚Üí Bonne r√©ponse : <strong>${correct}</strong>`;
    recordHistory(ok, val, correct);
    afterAnswer(ok);
  });

  // Boutons
  function bindStartLike(id){
    const el = document.getElementById(id); if(!el) return;
    const clone = el.cloneNode(true); el.parentNode.replaceChild(clone, el);
    clone.addEventListener('click', ()=>{
      readConfig(); if(!ensureDebugAuth()) return; const n = getRequestedCount(); if(n===null) return; prepareQueue(n);
      $('#config').classList.add('hidden'); $('#quiz').classList.remove('hidden'); $('#history').innerHTML=''; $('#endActions').classList.add('hidden');
      askNext();
    });
  }
  bindStartLike('start');
  bindStartLike('reset');
  bindStartLike('replay');

  $('#backToConfig').addEventListener('click', ()=>{
    $('#quiz').classList.add('hidden');
    $('#config').classList.remove('hidden');
    $('#prolBadge').classList.add('hidden');
  });

  // Mode & options
  $$('input[name="mode"]').forEach(r=> r.addEventListener('change', ()=>{
    STATE.mode = ($$('input[name="mode"]').find(x=>x.checked)||{}).value || 'qcm';
  }));
  $('#fullForm').addEventListener('change', ()=>{ STATE.fullForm = $('#fullForm').checked; });

  // Debug checkbox persistence
  $('#debugMode').addEventListener('change', ()=>{
    if(!$('#debugMode').checked){ sessionStorage.removeItem('debug'); STATE.debug=false; }
  });

  // Initialisation
  (async function init(){
    // restore debug flag
    if(sessionStorage.getItem('debug')==='1'){ $('#debugMode').checked = true; STATE.debug=true; }

    STATE.data = await loadVerbs();
    if(!STATE.data){ $('#start').disabled = true; return; }
    renderVerbChecks(STATE.data.verbs);
  })();
  </script>
</body>
</html>
